on script load:
    load yaml "plugins/Skript/globalpvp.yml" as "glpvp"
    set {_saved} to yaml value "pvp_enabled" from "glpvp"
    if {_saved} is set:
        set {globalpvp.enabled} to {_saved}
    else:
        set {globalpvp.enabled} to false
    delete {globalpvptimer.duration}
    delete {globalpvptimer.remaining}
    delete {globalpvptimer.action}
    set {graceperiod_disable} to false

on join:
    {joined::%player's uuid%} is not set
    if {glovalpvptimer.remaining} is not set:
        # the player gets their own grace period
        gracePeriod(player, 1800)
    else if {globalpvptimer.remaining} < 1800:
        # the player gets their own grace period
        gracePeriod(player, 1800)
    set {joined::%player's uuid%} to true

on damage of entity by entity:
    attacker is a player
    victim is a player
    if {globalpvp.enabled} is false:
        send "no pvp bc disabled" to console
        cancel event
    else if {singlepvp.disabled::%victim's uuid%} is set:
        send "no pvp bc %victim% is in grace" to console
        cancel event
    else if {singlepvp.disabled::%attacker's uuid%} is set:
        send "no pvp bc %attacker% is in grace" to console
        cancel event

function gracePeriod(player: player, duration: number):
    if {graceperiod_disable} is true:
        send "not giving grace period to %{_player}% because it is disabled" to console
    else:
        send "giving grace period to %{_player}% for %{_duration}%s" to console
        send "&a&lGRACE PERIOD &rYou have been granted a grace period, as you joined late. Your PVP will be disabled." to {_player}
        send "Your grace period ticks down &aeven when you are offline&f, so make use of it." to {_player}
        set {singlepvp.disabled::%{_player}'s uuid%} to {_duration}
        loop {_duration} times:
            if {singlepvp.stop::%{_player}'s uuid%} is set:
                delete {singlepvp.stop::%{_player}'s uuid%}
                delete {singlepvp.disabled::%{_player}'s uuid%}
                stop
            wait 1 second
            subtract 1 from {singlepvp.disabled::%{_player}'s uuid%}
        delete {singlepvp.disabled::%{_player}'s uuid%}
        send "&c&lYour PVP is now active!" to {_player}
        play sound "entity.wither.spawn" to {_player}

function setPvpState(enabled: boolean):
    set {globalpvp.enabled} to {_enabled}
    if {_enabled} is true:
        play sound "entity.wither.spawn" to all players
        send "&c&lPVP is now enabled!" to all players
    else:
        send "&a&lPVP is now disabled!" to all players
    load yaml "plugins/Skript/globalpvp.yml" as "glpvp"
    set yaml value "pvp_enabled" from "glpvp" to {_enabled}
    save yaml "glpvp"

function pad(n: number) :: string:
    if {_n} < 10:
        return "0%{_n}%"
    return "%{_n}%"



command /grace <boolean>:
    permission: globalpvp.grace
    trigger:
        set {graceperiod_disable} to arg 1

command /greset <offlineplayer>:
    permission: globalpvp.reset
    trigger:
        delete {joined::%arg 1's uuid%}
        send "deleted player join for %arg 1%"

command /gpvp [<text>]:
    permission: globalpvp.toggle
    trigger:
        if arg 1 is "on":
            setPvpState(true)
        else if arg 1 is "off":
            setPvpState(false)
        else:
            send "global pvp is %{globalpvp.enabled}%" to sender

command /gpvptimer <number> <text>:
    permission: globalpvp.timer
    trigger:
        # set {_timeArg::*} to split arg 1 at ":"
        # set {_unitCount} to size of {_timeArg::*}

        # if {_unitCount} = 3:
        #     set {_hours} to {_timeArg::1} parsed as integer
        #     set {_minutes} to {_timeArg::2} parsed as integer
        #     set {_seconds} to {_timeArg::3} parsed as integer
        # else if {_unitCount} = 2:
        #     set {_hours} to 0
        #     set {_minutes} to {_timeArg::1} parsed as integer
        #     set {_seconds} to {_timeArg::2} parsed as integer
        # else if {_unitCount} = 1:
        #     set {_hours} to 0
        #     set {_minutes} to 0
        #     set {_seconds} to {_timeArg::1} parsed as integer
        # else:
        #     send "&cusage: /globalpvptimer <seconds|mm:ss|hh:mm:ss> <enable|disable>" to sender
        #     stop

        # set {_total} to {_seconds} + ({_minutes} * 60) + ({_hours} * 3600)
        set {_total} to arg 1
        if {_total} <= 0:
            send "&cduration must be > 0 seconds." to sender
            stop

        if arg 2 is "enable":
            set {globalpvptimer.action} to true
        else if arg 2 is "disable":
            set {globalpvptimer.action} to false
        else:
            send "&cenable or disable" to sender
            stop

        set {globalpvptimer.duration} to {_total}
        set {globalpvptimer.remaining} to {_total}
        
        broadcast "&c&lPVP will be %arg 2%d in %displayTime({_total})%!"

        loop {_total} times:
            if {globalpvptimer.stop} is not set:
                wait 1 second
                subtract 1 from {globalpvptimer.remaining}
            else:
                delete {globalpvptimer.stop}
                stop
        if {globalpvptimer.action} is true:
            setPvpState(true)
        else:
            setPvpState(false)
        delete {globalpvptimer.duration}
        delete {globalpvptimer.remaining}
        delete {globalpvptimer.action}

command /gpvpstoptimer:
    permission: globalpvp.timer
    trigger:
        set {globalpvptimer.stop} to true
        delete {globalpvptimer.duration}
        delete {globalpvptimer.remaining}
        delete {globalpvptimer.action}
        send "stopping" to sender

command /graceperiod <player> <number>:
    permission: globalpvp.graceperiod
    trigger:
        gracePeriod(arg 1, arg 2)
        send "giving %arg 1% grace period of %arg 2%s"

command /graceperiodcancel <player>:
    permission: globalpvp.graceperiod
    trigger:
        set {singlepvp.stop::%arg 1's uuid%} to true
        delete {singlepvp.disabled::%arg 1's uuid%}
        send "removed grace period for %arg 1%"

placeholderapi placeholder with the prefix "gpvp":
    if the identifier is "state":
        if {globalpvptimer.action} is set:
            set the result to "pending"
        else if {globalpvp.enabled} is true:
            set the result to "enabled"
        else:
            set the result to "disabled"
    else if the identifier is "target":
        if {globalpvptimer.action} is true:
            set the result to "enabled"
        else if {globalpvptimer.action} is false:
            set the result to "disabled"
        else:
            set the result to ""
    else if the identifier is "timer":
        if {globalpvptimer.duration} is not set:
            set the result to "none"
        else:
            set {_total} to {globalpvptimer.remaining}
            set the result to displayTime({_total})
    else if the identifier is "graceperiod":
        if {singlepvp.disabled::%player's uuid%} is set:
            set the result to displayTime({singlepvp.disabled::%player's uuid%})
        else:
            set the result to ""
    else if the identifier is "graceperiod_active":
        if {singlepvp.disabled::%player's uuid%} is set:
            set the result to "true"
        else:
            set the result to "false"
            
    
function checkDeaths(player: player) :: boolean:
    if {deaths::%{_player}'s uuid%} is 2:
        if {_player} does not have permission "death.ascend":
            kick {_player} because "&c&lGAME OVER%newline%&cYou were finally killed by %{killer::%{_player}'s uuid%}%.%newline%%newline%&7Don't worry!%newline%&7Season 2.5 is running in late August."
            return true
        else:
            send "%{_player}% can ascend death" to console
    return false

# DEATHS

function lifeCrystal() :: itemstack:
    set {_item} to nether star with custom model data "life_crystal"
    # apply custom model data to {_item}:
    #     strings: "life_crystal"
    set name of {_item} to "&c&lLife Crystal &7(right click)"
    set lore of {_item} to " &7- &fAdds &cone life &fto a player.%newline% &7- &fCan only be used &conce&f!"
    return {_item}
    
on load:
    set {_lifecrystal} to lifeCrystal()
    register new shaped recipe for {_lifecrystal} using diamond block, nether star, emerald block, nether star, netherite block, nether star, gold block, nether star and redstone block with id "sabres:life_crystal"
    unlock custom recipe with id "sabres:life_crystal" for all players
    
on craft:
    item is a nether star
    name of item is "&c&lLife Crystal &7(right click)"
    play sound "entity.wither.spawn" to all players
    broadcast "&d%player% &dcrafted a &c&lLife Crystal&r&d!"
    
on right click with nether star:
    name of tool of player is "&c&lLife Crystal &7(right click)"
    if {heart_use::%player's uuid%} is set:
        play sound "entity.wither.break_block" to player
        send "&cYou have already used a Life Crystal before!" to player
    else:
        subtract 1 from {deaths::%player's uuid%}
        set {heart_use::%player's uuid%} to true
        play sound "entity.wither.ambient" to all players
        broadcast "&d%player% &dused a &c&lLife Crystal&r&d!"
        remove tool of player from player's inventory

on death of player:
    attacker is player
    victim is player
    if {globalpvp.enabled} is true:
        if {singlepvp.disabled::%victim's uuid%} is not set:
            add 1 to {deaths::%victim's uuid%}
            send "%victim% has died %{deaths::%victim's uuid%}% times" to console
            set {killer::%victim's uuid%} to attacker's name
            set {_res} to checkDeaths(victim)
            if {_res} is true:
                play sound "entity.enderdragon.growl" to all players
                broadcast "&c&lFINAL KILL &r%victim% was finally killed and can no longer join."
            else:
                gracePeriod(victim, 1800)
        else:
            send "death doesn't count because %victim% is in grace" to console
    else:
        send "death doesn't count because gpvp is off" to console

on join:
    set the maximum health of player to 15
    checkDeaths(player)

command /setdeaths <offlineplayer> <number>:
    permission: deaths.set
    trigger:
        set {deaths::%arg 1's uuid%} to arg 2
        send "Set %arg 1%'s deaths to %arg 2%" to sender
        checkDeaths(arg 1)
        
command /getdeaths <offlineplayer>:
    permission: deaths.get
    trigger:
        send "%arg 1% has %{deaths::%arg 1's uuid%}% deaths" to sender
        
command /resetheart <offlineplayer>:
    permission: deaths.resetheart
    trigger:
        delete {heart_use::%arg 1's uuid%}
        send "Deleted heart use for %arg 1%"

placeholderapi placeholder with the prefix "gdeath":
    if the identifier is "lives":
        set {_id} to player's uuid
        if {singlepvp.disabled::%{_id}%} is set:
            set the result to "&a⚔"
        else if {deaths::%{_id}%} is not set:
            set the result to "&c❤&c❤&7❤"
        else if {deaths::%{_id}%} is 0:
            set the result to "&c❤&c❤&7❤"
        else if {deaths::%player's uuid%} is 1:
            set the result to "&c❤&7❤&7❤"
        else if {deaths::%player's uuid%} is -1:
            set the result to "&c❤&c❤&c❤"
        else:
            set the result to "&7❤&7❤&7❤"

